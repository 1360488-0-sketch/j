<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è´ªåƒè›‡ Â· ç»å…¸HTML5ç‰ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            background: #1a2a32;
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Segoe UI', Roboto, system-ui, sans-serif;
        }
        .game-container {
            background: #0f1920;
            border-radius: 32px;
            padding: 24px;
            box-shadow: 0 20px 30px rgba(0,0,0,0.6);
        }
        canvas {
            display: block;
            margin: 0 auto;
            border-radius: 20px;
            background-color: #1e2f3a;
            box-shadow: inset 0 0 0 2px #2e4a5c, 0 10px 10px rgba(0,0,0,0.3);
            width: 400px;
            height: 400px;
        }
        .info-panel {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 18px;
            color: #bcd4de;
            font-weight: 600;
        }
        .score-box {
            background: #1e313a;
            padding: 10px 20px;
            border-radius: 60px;
            font-size: 1.4rem;
            letter-spacing: 1px;
            box-shadow: inset 0 -3px 0 #0f1a1f;
            border: 1px solid #3d6677;
            color: #e0f2f5;
        }
        .score-box span {
            color: #f5c542;
            margin-left: 10px;
            font-size: 2rem;
            font-weight: 800;
        }
        button {
            background: #2f4b5c;
            border: none;
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
            padding: 10px 28px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 7px 0 #12232b, 0 4px 12px rgba(0,0,0,0.5);
            transition: 0.08s linear;
            border: 1px solid #5b889c;
            letter-spacing: 1px;
        }
        button:active {
            transform: translateY(5px);
            box-shadow: 0 2px 0 #12232b, 0 6px 12px rgba(0,0,0,0.4);
        }
        .hint {
            color: #6d95a5;
            margin-top: 15px;
            text-align: center;
            font-size: 0.95rem;
        }
        .hint kbd {
            background: #253b44;
            padding: 3px 8px;
            border-radius: 30px;
            color: #f0d89f;
            margin: 0 4px;
            font-weight: 600;
            border: 1px solid #3b6273;
        }
    </style>
</head>
<body>
<div class="game-container">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    <div class="info-panel">
        <div class="score-box">ğŸ å¾—åˆ† <span id="scoreDisplay">0</span></div>
        <button id="restartBtn">â†» é‡æ¥</button>
    </div>
    <div class="hint">
        <kbd>â†‘</kbd> <kbd>â†“</kbd> <kbd>â†</kbd> <kbd>â†’</kbd> ç§»åŠ¨ Â Â  <kbd>ç©ºæ ¼</kbd> æš‚åœ/ç»§ç»­
    </div>
</div>

<script>
    (function() {
        // ---------- æ¸¸æˆé…ç½® ----------
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreSpan = document.getElementById('scoreDisplay');

        const GRID_SIZE = 20;          // 20x20 ç½‘æ ¼
        const CELL_SIZE = canvas.width / GRID_SIZE; // 20px

        // åˆå§‹è›‡: ä¸‰ä¸ªå•å…ƒæ ¼ (ä»ä¸­é—´åå·¦å¼€å§‹)
        const START_SNAKE = [
            { x: 9, y: 10 },  // å¤´ (æœ€å³ä¾§)
            { x: 8, y: 10 },
            { x: 7, y: 10 }
        ];

        // æ–¹å‘å¸¸é‡
        const DIRS = {
            'UP':    { x: 0, y: -1 },
            'DOWN':  { x: 0, y: 1 },
            'LEFT':  { x: -1, y: 0 },
            'RIGHT': { x: 1, y: 0 }
        };

        // ---------- æ¸¸æˆçŠ¶æ€ ----------
        let snake = [...START_SNAKE.map(cell => ({...cell}))];  // å½“å‰è›‡ (æ•°ç»„ç´¢å¼•0æ˜¯å¤´éƒ¨)
        let food = { x: 12, y: 10 };      // é£Ÿç‰©åæ ‡ï¼Œç¨åä¼šç”¨åˆæ³•åæ ‡é‡ç½®
        let direction = DIRS.RIGHT;        // å½“å‰ç§»åŠ¨æ–¹å‘
        let nextDirection = DIRS.RIGHT;    // ä¸‹ä¸€æ¬¡ç§»åŠ¨å®é™…æ–¹å‘ (ç”¨äºé˜²æŠ–)
        let score = 0;
        let gameOver = false;
        let winFlag = false;               // æ˜¯å¦èƒœåˆ© (ç½‘æ ¼å¡«æ»¡)
        let paused = false;
        let gameInterval = null;
        const MOVE_INTERVAL_MS = 180;       // ç§»åŠ¨é—´éš” (æ¯«ç§’)

        // ---------- å·¥å…·å‡½æ•°ï¼šéšæœºæ•´æ•° [min,max] ----------
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // ---------- ç”Ÿæˆæ–°é£Ÿç‰© (é¿å¼€è›‡èº«) ----------
        function generateFood() {
            // å¦‚æœè›‡å·²ç»å æ»¡æ‰€æœ‰æ ¼å­ => èƒœåˆ©
            if (snake.length >= GRID_SIZE * GRID_SIZE) {
                winFlag = true;
                gameOver = true;
                clearInterval(gameInterval);
                gameInterval = null;
                return false;
            }

            // æ”¶é›†æ‰€æœ‰ç©ºé—²æ ¼å­
            const snakeSet = new Set(snake.map(cell => `${cell.x},${cell.y}`));
            const freeCells = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    if (!snakeSet.has(`${col},${row}`)) {
                        freeCells.push({ x: col, y: row });
                    }
                }
            }

            if (freeCells.length === 0) {
                // ç†è®ºä¸Šè›‡é•¿è¾¾åˆ°400æ—¶ä¼šè¿›å…¥è¿™é‡Œï¼Œä½†ä¸Šé¢çš„åˆ¤æ–­å·²ç»å¤„ç†ï¼Œä¸è¿‡ä»¥é˜²ä¸‡ä¸€
                winFlag = true;
                gameOver = true;
                clearInterval(gameInterval);
                gameInterval = null;
                return false;
            }

            const randomIndex = randomInt(0, freeCells.length - 1);
            food = { ...freeCells[randomIndex] };
            return true;
        }

        // ---------- é‡ç½®æ¸¸æˆ ----------
        function resetGame() {
            // åœæ­¢æ—§å¾ªç¯
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }

            // é‡ç½®æ•°æ®
            snake = START_SNAKE.map(cell => ({...cell}));
            direction = DIRS.RIGHT;
            nextDirection = DIRS.RIGHT;
            score = 0;
            gameOver = false;
            winFlag = false;
            paused = false;
            scoreSpan.textContent = '0';

            // ç”Ÿæˆç¬¬ä¸€ä¸ªé£Ÿç‰© (ç¡®ä¿ä¸åœ¨è›‡èº«ä¸Š)
            const snakeSet = new Set(snake.map(c => `${c.x},${c.y}`));
            let candidateFood;
            do {
                candidateFood = {
                    x: randomInt(5, GRID_SIZE - 6),  // é¿å…å¤ªé è¾¹ï¼Œä½†ä¸æ˜¯å¿…é¡»
                    y: randomInt(5, GRID_SIZE - 6)
                };
            } while (snakeSet.has(`${candidateFood.x},${candidateFood.y}`));
            food = candidateFood;

            // ç»˜åˆ¶åˆå§‹å¸§
            drawGame();

            // å¯åŠ¨æ–°å¾ªç¯
            if (!gameInterval) {
                gameInterval = setInterval(moveSnake, MOVE_INTERVAL_MS);
            }
        }

        // ---------- è›‡ç§»åŠ¨é€»è¾‘ (æ¯ä¸€æ­¥) ----------
        function moveSnake() {
            // å¦‚æœæ¸¸æˆç»“æŸæˆ–æš‚åœï¼Œä¸ç§»åŠ¨
            if (gameOver || paused) return;

            // 1. åº”ç”¨æœ‰æ•ˆæ–¹å‘ (ä¸èƒ½åå‘)
            const cannotReverse = (
                (nextDirection === DIRS.UP && direction === DIRS.DOWN) ||
                (nextDirection === DIRS.DOWN && direction === DIRS.UP) ||
                (nextDirection === DIRS.LEFT && direction === DIRS.RIGHT) ||
                (nextDirection === DIRS.RIGHT && direction === DIRS.LEFT)
            );

            if (!cannotReverse) {
                direction = nextDirection;
            }

            // 2. è®¡ç®—æ–°å¤´éƒ¨
            const head = snake[0];
            const newHead = {
                x: head.x + direction.x,
                y: head.y + direction.y
            };

            // 3. æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
            const isEating = (newHead.x === food.x && newHead.y === food.y);

            // 4. æ„å»ºæ–°è›‡ (å…ˆæ’å…¥æ–°å¤´)
            let newSnake = [newHead, ...snake];

            if (!isEating) {
                // æ²¡åƒåˆ°é£Ÿç‰©ï¼Œç§»é™¤å°¾éƒ¨
                newSnake.pop();
            }

            // 5. ç¢°æ’æ£€æµ‹ (è¾¹ç•Œ & è‡ªèº«)
            //    è¾¹ç•Œæ£€æŸ¥
            const headOut = newHead.x < 0 || newHead.x >= GRID_SIZE || newHead.y < 0 || newHead.y >= GRID_SIZE;

            //    è‡ªèº«ç¢°æ’ (æ³¨æ„æ–°è›‡çš„å¤´éƒ¨æ˜¯å¦ä¸åé¢é‡å¤ï¼Œå¿½ç•¥ç¬¬ä¸€æ ¼[å¤´éƒ¨è‡ªèº«])
            const selfCollision = !headOut && newSnake.slice(1).some(segment => segment.x === newHead.x && segment.y === newHead.y);

            if (headOut || selfCollision) {
                gameOver = true;
                winFlag = false;      // æ™®é€šå¤±è´¥
                clearInterval(gameInterval);
                gameInterval = null;
                drawGame();            // ç»˜åˆ¶ç»“æŸç”»é¢
                return;
            }

            // 6. æ›´æ–°è›‡
            snake = newSnake;

            // 7. å¦‚æœåƒåˆ°é£Ÿç‰©ï¼ŒåŠ åˆ† + ç”Ÿæˆæ–°é£Ÿç‰©ï¼Œå¹¶ä¸”ä¸ç”¨popå°¾éƒ¨ (å·²å¤„ç†)
            if (isEating) {
                score++;
                scoreSpan.textContent = score;

                // å°è¯•ç”Ÿæˆæ–°é£Ÿç‰©ï¼Œå¦‚æœç”Ÿæˆå¤±è´¥(èƒœåˆ©æˆ–æ— ç©ºä½)ä¼šåœ¨å‡½æ•°å†…è®¾ç½®gameOver/winFlag
                const success = generateFood();

                // å¦‚æœèƒœåˆ© (generateFood é‡Œé¢å¯èƒ½è®¾ç½® gameOver = true, winFlag = true)
                if (gameOver) {
                    // èƒœåˆ©æˆ–è€…æ— ç©ºä½ (å·²ç»clearInterval)
                    drawGame();
                    return;
                }

                // å¦‚æœç”Ÿæˆé£Ÿç‰©å¤±è´¥ä¸”æ²¡æœ‰è®¾ç½®gameOver (å…œåº•)
                if (!success) {
                    // ä½†generateFoodå†…éƒ¨é‡åˆ°æ— ç©ºä½ä¼šç½®gameOverï¼Œæ­¤å¤„ä¸å†é‡å¤
                }
            }

            // 8. é‡ç»˜
            drawGame();
        }

        // ---------- ç»˜åˆ¶ç”»å¸ƒ ----------
        function drawGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼çº¿ (æµ…æš—çº¿)
            ctx.strokeStyle = '#2d4b5a';
            ctx.lineWidth = 0.6;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.strokeStyle = '#2d4b5a';
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            // ç»˜åˆ¶é£Ÿç‰©
            ctx.shadowColor = '#ffb347';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ff6347';   // ç•ªèŒ„çº¢
            ctx.beginPath();
            const fx = food.x * CELL_SIZE + CELL_SIZE/2;
            const fy = food.y * CELL_SIZE + CELL_SIZE/2;
            ctx.arc(fx, fy, CELL_SIZE/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            // é«˜å…‰
            ctx.shadowBlur = 4;
            ctx.fillStyle = '#ff9f7a';
            ctx.beginPath();
            ctx.arc(fx-2, fy-2, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;  // å…³æ‰é˜´å½±é¿å…å½±å“è›‡

            // ç»˜åˆ¶è›‡èº«ä½“ (ä»åå¾€å‰ç»˜ï¼Œå°¾éƒ¨åœ¨æœ€ä¸‹å±‚ï¼Œå¤´éƒ¨çªå‡º)
            for (let i = snake.length - 1; i >= 0; i--) {
                const seg = snake[i];
                const isHead = (i === 0);
                const x = seg.x * CELL_SIZE;
                const y = seg.y * CELL_SIZE;
                const padding = isHead ? 2 : 3;
                const radius = 4;

                // èº«ä½“é¢œè‰²ï¼šå¤´éƒ¨äº®ç»¿ï¼Œèº«ä½“æ·±ç»¿æ¸å˜
                if (isHead) {
                    ctx.fillStyle = '#a3d930';  // äº®ç»¿å¤´
                } else {
                    // æ¸å˜èº«ä½“ï¼Œè¶Šé åç¨æš—
                    const gradient = ctx.createRadialGradient(x+6, y+6, 2, x+10, y+10, 15);
                    gradient.addColorStop(0, '#4e8d5c');
                    gradient.addColorStop(1, '#2a6e3a');
                    ctx.fillStyle = gradient;
                }

                // ç»˜åˆ¶åœ†è§’æ–¹æ ¼
                ctx.beginPath();
                ctx.roundRect(x + 1.5, y + 1.5, CELL_SIZE - 3, CELL_SIZE - 3, 5);
                ctx.fill();

                // çœ¼ç› (ä»…å¤´éƒ¨)
                if (isHead) {
                    ctx.fillStyle = '#f5f2e0';
                    ctx.beginPath();
                    ctx.arc(x + 13, y + 7, 2.2, 0, Math.PI * 2);
                    ctx.arc(x + 7, y + 7, 2.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#1e2e24';
                    ctx.beginPath();
                    ctx.arc(x + 14, y + 6, 1.2, 0, Math.PI * 2);
                    ctx.arc(x + 8, y + 6, 1.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // ç»˜åˆ¶æ¸¸æˆç»“æŸ/èƒœåˆ©è’™å±‚
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 28px "Segoe UI", Roboto, sans-serif';
                ctx.fillStyle = '#fcd9b8';
                ctx.shadowColor = '#0a1a1f';
                ctx.shadowBlur = 8;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (winFlag) {
                    ctx.fillText('ğŸ† èƒœåˆ©ï¼', 200, 180);
                } else {
                    ctx.fillText('ğŸ’€ æ¸¸æˆç»“æŸ', 200, 180);
                }
                ctx.shadowBlur = 0;
            } else if (paused) {
                // æš‚åœå±‚
                ctx.fillStyle = 'rgba(0, 20, 20, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.font = 'bold 28px "Segoe UI", Roboto, sans-serif';
                ctx.fillStyle = '#bee0e9';
                ctx.shadowColor = '#0a1a1f';
                ctx.shadowBlur = 8;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â¸ æš‚åœ', 200, 200);
                ctx.shadowBlur = 0;
            }
        }

        // è¾…åŠ© roundRect
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            this.moveTo(x + r, y);
            this.lineTo(x + w - r, y);
            this.quadraticCurveTo(x + w, y, x + w, y + r);
            this.lineTo(x + w, y + h - r);
            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            this.lineTo(x + r, y + h);
            this.quadraticCurveTo(x, y + h, x, y + h - r);
            this.lineTo(x, y + r);
            this.quadraticCurveTo(x, y, x + r, y);
            this.closePath();
            return this;
        };

        // ---------- é”®ç›˜æ§åˆ¶ ----------
        function handleKeyDown(e) {
            const key = e.key;
            // é˜»æ­¢ç®­å¤´é”®æ»šåŠ¨ã€ç©ºæ ¼é”®æŒ‰ä¸‹å¼¹çª—
            if (key.startsWith('Arrow') || key === ' ' || key === 'Spacebar') {
                e.preventDefault();
            }

            // é‡å¯ (Ré”®ä¹Ÿå¯ä»¥é‡å¯ï¼Œæ–¹ä¾¿)
            if (key === 'r' || key === 'R') {
                resetGame();
                return;
            }

            // ç©ºæ ¼æš‚åœ/ç»§ç»­ (ä»…å½“æ¸¸æˆæœªç»“æŸæ—¶)
            if (key === ' ' || key === 'Spacebar' || key === 'Space') {
                e.preventDefault();
                if (gameOver) {
                    // æ¸¸æˆç»“æŸæ—¶ç©ºæ ¼æ— æ•ˆ (ä½†å¯ä»¥ç”¨é‡å¯)
                    return;
                }
                paused = !paused;
                drawGame();  // ç«‹å³æ˜¾ç¤º/éšè—æš‚åœå±‚
                return;
            }

            // æ–¹å‘ (åªå¤„ç†ç®­å¤´)
            if (gameOver || paused) return;

            switch (key) {
                case 'ArrowUp':
                    nextDirection = DIRS.UP;
                    break;
                case 'ArrowDown':
                    nextDirection = DIRS.DOWN;
                    break;
                case 'ArrowLeft':
                    nextDirection = DIRS.LEFT;
                    break;
                case 'ArrowRight':
                    nextDirection = DIRS.RIGHT;
                    break;
                default: return;
            }
        }

        // é˜²æ­¢é¡µé¢éšç€æ–¹å‘é”®æ»šåŠ¨ (å†æ¬¡ä¿é™©)
        window.addEventListener('keydown', function(e) {
            if (e.key.startsWith('Arrow') || e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
            }
        }, { passive: false });

        // ä¸»é”®ç›˜ç›‘å¬
        document.addEventListener('keydown', handleKeyDown);

        // é‡å¯æŒ‰é’®
        document.getElementById('restartBtn').addEventListener('click', resetGame);

        // è§¦æ‘¸å±å‹å¥½: é˜»æ­¢canvasä¸Šçš„è§¦æ‘¸äº‹ä»¶å¼•èµ·é¡µé¢ç¼©æ”¾ (ä½†åŸºæœ¬æ“ä½œè¿˜æ˜¯é”®ç›˜)
        canvas.addEventListener('touchstart', (e) => e.preventDefault());

        // å¯åŠ¨æ¸¸æˆ
        resetGame();

        // å¯é€‰ï¼šçª—å£å¤±ç„¦æ—¶ä¸æ¸…é™¤çŠ¶æ€ï¼Œä½†æš‚åœä¸€ä¸‹? (ä¸åšå¼ºåˆ¶)
        window.addEventListener('blur', () => {
            // å¦‚æœä¸æƒ³åœ¨åˆ‡å‡ºæ—¶æ¸¸æˆç»§ç»­ï¼Œå¯ä»¥è‡ªåŠ¨æš‚åœï¼ˆä½†ä¸ºäº†ä½“éªŒï¼Œä¿æŒåŸæ ·ï¼‰
            // è¿™é‡Œä¸åšæ”¹åŠ¨
        });

        // ç¡®ä¿canvasè·å¾—é”®ç›˜äº‹ä»¶ (ä½†documentå·²ç›‘å¬)
        canvas.setAttribute('tabindex', '0');  // å¯é€‰ï¼Œä½†å¯èƒ½æ˜¾ç¤ºè½®å»“
        canvas.style.outline = 'none';
    })();
</script>
</body>
</html>